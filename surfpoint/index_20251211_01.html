<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Japan Surf Condition Map</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Helvetica Neue', Arial, sans-serif; overflow: hidden; }
        #map { height: 100%; width: 100%; background: #e5e5e5; }

        /* --- 情報パネル --- */
        #info-panel {
            position: absolute; top: 15px; right: 15px; width: 280px;
            background: rgba(255, 255, 255, 0.98); 
            padding: 12px 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15); z-index: 1000; display: none;
            backdrop-filter: blur(5px);
            pointer-events: auto; 
        }
        
        #p-data-time {
            position: absolute; top: 12px; right: 15px;
            font-size: 0.75rem; color: #e74c3c; font-weight: bold;
        }

        h3#p-name {
            margin-top: 0; margin-bottom: 8px;
            font-size: 1.1rem;
            line-height: 1.2;
        }

        .row { 
            display: flex; justify-content: space-between; 
            margin-bottom: 6px;
            border-bottom: 1px solid #eee; 
            padding-bottom: 3px;
            align-items: baseline;
        }
        
        .label { color: #666; font-size: 0.8rem; }
        .val { font-weight: bold; color: #333; text-align: right; font-size: 0.9rem; }
        .sub-val { font-size: 0.75rem; color: #888; font-weight: normal; display: block; line-height: 1.1; }
        
        .note-text { 
            font-size: 0.65rem; color: #999; 
            margin-top: 2px; margin-bottom: 6px; 
            line-height: 1.2; text-align: right; 
        }

        .tide-tag {
            display: inline-block; padding: 1px 6px; border-radius: 3px; 
            font-size: 0.75rem; color: white; background: #555; margin-right: 4px;
        }
        .tide-trend { font-weight: bold; color: #007bff; font-size: 0.85rem; }
        .tide-trend.down { color: #dc3545; }

        #tide-graph-container {
            margin-top: 4px; text-align: center;
            background: linear-gradient(to bottom, #fcfcfc, #f0f8ff);
            border-radius: 6px; padding: 5px 0; border: 1px solid #e0e0e0;
        }
        canvas { width: 100%; height: 50px; display: block; }
        .graph-labels { font-size: 0.65rem; color:#999; display:flex; justify-content:space-between; padding:0 8px; margin-top:2px; }

        /* --- マーカー --- */
        .surf-pin-container {
            position: relative; width: 50px; height: 50px;
            display: flex; align-items: center; justify-content: center;
        }
        .wave-core {
            width: 16px; height: 16px; border-radius: 50%; border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); z-index: 2; transition: all 0.3s ease;
        }
        .surf-pin-container:hover .wave-core { transform: scale(1.2); box-shadow: 0 0 15px rgba(0,0,0,0.5); cursor: pointer; }

        .wind-ring {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1; transition: transform 0.5s linear;
        }
        .arrow-pointer {
            position: absolute; top: 2px; left: 50%; transform: translateX(-50%);
            width: 0; height: 0; 
            border-left: 6px solid transparent; border-right: 6px solid transparent;
            border-bottom: 14px solid #888; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }

        .c-calm { background: #3498db; }
        .c-mod { background: #f1c40f; }
        .c-high { background: #e74c3c; }
        .c-none { background: #b0b0b0; }

        /* 背景風アニメーション */
        .wind-arrow-icon {
            display: flex; align-items: center; justify-content: center; pointer-events: none; 
        }
        .arrow-svg path {
            animation-name: flow; animation-timing-function: linear; animation-iteration-count: infinite;
        }
        @keyframes flow {
            0% { opacity: 0; transform: translateY(8px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-8px); }
        }

        /* --- タイムスライダー & コントロール --- */
        #time-control {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 600px;
            background: rgba(255,255,255,0.95); padding: 12px 20px;
            border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 2000; 
            display: flex; flex-direction: row; align-items: center; gap: 15px;
            transition: all 0.3s ease;
        }

        #play-btn {
            width: 40px; height: 40px; border-radius: 50%; border: none; flex-shrink: 0;
            background: #3498db; color: white; font-size: 1.1rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.2s;
        }
        #play-btn:hover { background: #2980b9; }
        
        .slider-wrapper { flex-grow: 1; position: relative; }
        
        input[type=range] { 
            width: 100%; cursor: pointer; margin: 0;
            height: 6px; -webkit-appearance: none; background: #ddd; border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 18px; height: 18px; background: #3498db; border-radius: 50%; cursor: pointer;
        }

        .slider-labels {
            display: flex; justify-content: space-between; margin-top: 4px;
            font-size: 0.65rem; color: #666; padding: 0 2px;
        }
        
        #current-time-display {
            font-size: 0.95rem; font-weight: bold; color: #333; min-width: 110px; text-align: center;
        }

        /* --- Copyright --- */
        #copyright {
            position: absolute; bottom: 5px; left: 10px; 
            font-size: 0.6rem; color: rgba(0,0,0,0.6);
            z-index: 1000; pointer-events: auto;
            text-align: left;
            background: rgba(255,255,255,0.7);
            padding: 2px 6px; border-radius: 4px;
            line-height: 1.2;
        }
        #copyright a { color: #333; text-decoration: none; border-bottom: 1px dotted #999; }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.8); z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; font-weight: bold; color: #555;
        }

        /* --- スマホ用レイアウト調整 --- */
        @media (max-width: 600px) {
            #time-control {
                bottom: 35px; padding: 10px 15px; width: 92%; border-radius: 15px;
                flex-wrap: wrap; gap: 8px;
            }
            
            #current-time-display {
                width: 100%; order: -1; margin-bottom: 2px; font-size: 1.0rem;
                border-bottom: 1px solid #eee; padding-bottom: 4px;
            }

            #play-btn { width: 36px; height: 36px; font-size: 0.9rem; }
            .slider-wrapper { width: calc(100% - 46px); }
            
            #info-panel {
                width: 90%; 
                top: 15px; 
                left: 0; right: 0; margin: 0 auto; 
                padding: 10px 15px;
            }
            
            #copyright { bottom: 2px; left: 5px; font-size: 0.55rem; padding: 1px 4px;}
        }
    </style>
</head>
<body>

    <div id="loading-overlay">データ取得中...</div>

    <div id="map"></div>
    
    <div id="copyright">
        &copy; 2025 Slosea. All rights reserved.<br>
        Weather data by <a href="https://open-meteo.com/" target="_blank">Open-Meteo.com</a> | Map &copy; <a href="https://leafletjs.com/">Leaflet</a>
    </div>

    <div id="time-control">
        <div id="current-time-display">現在</div>
        <button id="play-btn">▶</button>
        <div class="slider-wrapper">
            <input type="range" id="time-slider" min="0" max="23" value="0" step="1">
            <div class="slider-labels">
                <span>0</span><span>6</span><span>12</span><span>18</span><span>+24h</span>
            </div>
        </div>
    </div>

    <div id="info-panel">
        <div id="p-data-time">現在</div>
        <h3 id="p-name">-</h3>
        
        <div class="row" style="border-bottom: none; margin-bottom: 0;">
            <span class="label">波高 (目安)</span>
            <div style="text-align:right;">
                <div id="p-wave-cond" class="val">-</div>
                <div id="p-wave" class="sub-val">- m</div>
            </div>
        </div>
        <div class="note-text" style="padding-bottom: 4px; border-bottom: 1px solid #eee;">
            ※地形や潮回りによりサイズは前後します
        </div>

        <div class="row">
            <span class="label">うねり</span>
            <div style="text-align:right;">
                <span id="p-swell" class="val">-</span>
            </div>
        </div>

        <div class="row">
            <span class="label">風速</span>
            <div style="text-align:right;">
                <span id="p-wind" class="val">-</span>
                <div id="p-wdir" class="sub-val">-</div>
            </div>
        </div>

        <hr style="border:0; border-top:1px solid #eee; margin: 4px 0 8px 0;">

        <div class="row" style="border: none; margin-bottom: 2px;">
            <span class="label">潮回り</span>
            <div style="text-align:right;">
                <div style="margin-bottom:2px;">
                    <span id="p-tide-name" class="tide-tag">-</span>
                    <span id="p-moon-age" style="font-size:0.75rem; color:#999;">(月齢 -)</span>
                </div>
                <div id="p-tide-trend" class="val">-</div>
            </div>
        </div>

        <div id="tide-graph-container">
            <canvas id="tideCanvas" width="280" height="50"></canvas>
            <div class="graph-labels">
                <span>0</span><span>6</span><span>12</span><span>18</span><span>24</span>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // --- 状態管理 ---
        let globalData = [];
        let currentHourIndex = 0;
        let isPlaying = false;
        let playInterval = null;
        let selectedSpotIndex = null;
        
        const today = new Date();
        const hourLabels = [];
        for(let i=0; i<24; i++) {
            const d = new Date(today.getTime());
            d.setHours(today.getHours() + i);
            d.setMinutes(0);
            hourLabels.push(d);
        }

        // --- マップ初期化 ---
        const southWest = L.latLng(20.0, 122.0);
        const northEast = L.latLng(46.0, 154.0);
        const bounds = L.latLngBounds(southWest, northEast);

        const map = L.map('map', { 
            zoomControl: false,
            attributionControl: false, 
            maxBounds: bounds,
            maxBoundsViscosity: 1.0,
            minZoom: 5
        }).setView([37.5, 139.0], 5); 

        L.control.zoom({ position: 'topleft' }).addTo(map);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19, attribution: '&copy; CARTO', bounds: bounds
        }).addTo(map);

        map.on('click', () => {
            document.getElementById('info-panel').style.display = 'none';
            selectedSpotIndex = null;
        });
        const panel = document.getElementById('info-panel');
        L.DomEvent.disableClickPropagation(panel);
        L.DomEvent.disableClickPropagation(document.getElementById('time-control'));

        // --- ポイント定義（補正係数 adjust を追加） ---
        // adjust: 1.0 = そのまま, 0.7 = 70%のサイズに縮小 (湾内などに使用)
        const spots = [
            // --- 北海道・東北 ---
            { name: "北海道 - 浜厚真", lat: 42.605, lon: 141.832 },
            { name: "北海道 - 銭函", lat: 43.145, lon: 141.220 },
            { name: "北海道 - 室蘭イタンキ", lat: 42.327, lon: 141.037 },
            { name: "北海道 - 浜中", lat: 43.160, lon: 145.120 },
            { name: "青森 - 三沢", lat: 40.702, lon: 141.428 },
            { name: "青森 - 深浦", lat: 40.650, lon: 139.920 },
            { name: "岩手 - 久慈", lat: 40.190, lon: 141.780 },
            { name: "岩手 - 浪板", lat: 39.358, lon: 141.933 },
            { name: "秋田 - 男鹿", lat: 39.850, lon: 139.750 }, 
            { name: "宮城 - 仙台新港", lat: 38.276, lon: 141.026 },
            { name: "山形 - 湯野浜", lat: 38.770, lon: 139.730 },
            { name: "福島 - 北泉", lat: 37.647, lon: 141.25 }, // 沖合調整済み
            { name: "福島 - 岩沢", lat: 37.268, lon: 141.25 }, // 沖合調整済み
            { name: "福島 - 勿来", lat: 36.870, lon: 140.780 },
            
            // --- 北陸・日本海 ---
            { name: "新潟 - 直江津", lat: 37.180, lon: 138.250 },
            { name: "日本海 - 新潟", lat: 37.880, lon: 138.940 },
            { name: "石川 - 柴垣", lat: 36.908, lon: 136.762 },
            { name: "福井 - 鳥居浜", lat: 35.540, lon: 135.400 },
            { name: "京都 - 八丁浜", lat: 35.688, lon: 135.062 },
            { name: "京都 - 葛野浜", lat: 35.615, lon: 134.920 },
            { name: "鳥取 - 白兎", lat: 35.540, lon: 134.150 },
            { name: "島根 - 波子", lat: 35.000, lon: 132.170 },

            // --- 茨城・千葉 ---
            { name: "茨城 - 河原子", lat: 36.530, lon: 140.630 },
            { name: "茨城 - 大洗", lat: 36.307, lon: 140.575 },
            { name: "茨城 - トップサンテ", lat: 36.195, lon: 140.575 },
            { name: "千葉 - 片貝", lat: 35.538, lon: 140.460 },
            { name: "千葉 - 一宮", lat: 35.365, lon: 140.395 },
            { name: "千葉 - 太東", lat: 35.300, lon: 140.400 },
            { name: "千葉 - 御宿", lat: 35.182, lon: 140.355, adjust: 0.75 }, // ★補正: 25%ダウン
            { name: "千葉 - 部原", lat: 35.140, lon: 140.320 },
            { name: "千葉 - 鴨川", lat: 35.105, lon: 140.105 },
            { name: "千葉 - 和田", lat: 35.038, lon: 140.023 },
            { name: "千葉 - 千倉", lat: 34.960, lon: 139.960 },
            
            // --- 関東・伊豆・東海 ---
            { name: "東京 - 新島(羽伏浦)", lat: 34.360, lon: 139.270 },
            { name: "湘南 - 由比ガ浜", lat: 35.3120, lon: 139.5415 }, 
            { name: "湘南 - 七里ヶ浜", lat: 35.3058, lon: 139.5105 }, 
            { name: "湘南 - 鵠沼", lat: 35.3165, lon: 139.4685 },     
            { name: "湘南 - 茅ヶ崎", lat: 35.3168, lon: 139.4045 },   
            { name: "湘南 - 平塚", lat: 35.3155, lon: 139.3615 },     
            { name: "西湘 - 吉浜", lat: 35.1505, lon: 139.1125 },     
            { name: "静岡 - 宇佐美", lat: 35.000, lon: 139.130, adjust: 0.6 }, // ★補正: 40%ダウン & 座標微調整
            { name: "静岡 - 白浜", lat: 34.688, lon: 138.975 },
            { name: "静岡 - 多々戸浜", lat: 34.660, lon: 138.930 },
            { name: "静岡 - 静波", lat: 34.752, lon: 138.275 },
            { name: "静岡 - 御前崎", lat: 34.595, lon: 138.225 },
            { name: "愛知 - ロコ", lat: 34.600, lon: 137.180 },
            { name: "愛知 - 伊良湖", lat: 34.598, lon: 137.150 }, 
            { name: "三重 - 国府の浜", lat: 34.350, lon: 136.880 },

            // --- 関西・四国 ---
            { name: "和歌山 - 磯の浦", lat: 34.257, lon: 135.075, adjust: 0.7 }, // ★補正: 湾内のため
            { name: "徳島 - 小松海岸", lat: 34.050, lon: 134.600 },
            { name: "徳島 - 海部", lat: 33.590, lon: 134.350 },
            { name: "高知 - 生見", lat: 33.542, lon: 134.305 },
            { name: "高知 - 仁淀", lat: 33.480, lon: 133.550 },
            { name: "高知 - 入野", lat: 33.020, lon: 133.005 },

            // --- 九州・沖縄 ---
            { name: "福岡 - 釣川", lat: 33.875, lon: 130.535 },
            { name: "福岡 - 三苫", lat: 33.705, lon: 130.422 }, 
            { name: "福岡 - 芥屋", lat: 33.615, lon: 130.130 },
            { name: "佐賀 - 立神", lat: 33.430, lon: 129.980 },
            { name: "長崎 - 脇岬", lat: 32.580, lon: 129.780 },
            { name: "宮崎 - お倉ヶ浜", lat: 32.410, lon: 131.670 },
            { name: "宮崎 - 木崎浜", lat: 31.825, lon: 131.445 },
            { name: "宮崎 - 恋ヶ浦", lat: 31.420, lon: 131.330 },
            { name: "鹿児島 - 江口浜", lat: 31.630, lon: 130.300 },
            { name: "鹿児島 - 種子島(鉄浜)", lat: 30.380, lon: 130.980 },
            { name: "鹿児島 - 奄美手広", lat: 28.430, lon: 129.620 },
            { name: "沖縄 - 伊計島", lat: 26.390, lon: 127.990 },
            { name: "沖縄 - 砂辺", lat: 26.328, lon: 127.745 },
            { name: "沖縄 - スーサイド", lat: 26.080, lon: 127.670 }
        ];

        const spotMarkers = [];
        const windLayerGroup = L.layerGroup().addTo(map);

        function getDirText(deg) {
            const dirs = ['北', '北東', '東', '南東', '南', '南西', '西', '北西'];
            return dirs[Math.round(deg / 45) % 8];
        }

        function getSurfConditionText(height) {
            if (height === null || height === undefined) return "データなし";
            if (height < 0.30) return "ひざ";
            if (height < 0.40) return "ひざ前後";
            if (height < 0.50) return "もも前後";
            if (height < 0.60) return "もも腰";
            if (height < 0.70) return "腰前後";
            if (height < 0.80) return "腰腹";
            if (height < 0.90) return "腹前後";
            if (height < 1.00) return "腹胸前後";
            if (height < 1.10) return "胸前後";
            if (height < 1.20) return "胸前後";
            if (height < 1.30) return "胸肩前後";
            if (height < 1.40) return "胸肩前後";
            if (height < 1.50) return "肩前後";
            if (height < 1.60) return "肩前後";
            if (height < 1.70) return "頭前後";
            if (height < 1.80) return "頭オーバー";
            return "クローズ"; 
        }

        // --- Tide Logic ---
        function getTideInfo(targetDate) {
            const knownNewMoon = new Date(2024, 0, 11, 20, 57); 
            const cycle = 29.53059;
            const diffTime = targetDate.getTime() - knownNewMoon.getTime();
            const diffDays = diffTime / (1000 * 60 * 60 * 24);
            let moonAge = diffDays % cycle;
            if (moonAge < 0) moonAge += cycle;

            const lunarDate = Math.floor(moonAge) + 1;
            let name = "中潮";
            
            if ([1, 2, 15, 16, 17, 30].includes(lunarDate)) name = "大潮";
            else if ([3, 4, 5, 18, 19, 20, 21].includes(lunarDate)) name = "中潮";
            else if ([6, 7, 8, 22, 23, 24].includes(lunarDate)) name = "小潮";
            else if ([9, 25].includes(lunarDate)) name = "長潮";
            else if ([10, 11, 12, 13, 14, 26, 27, 28, 29].includes(lunarDate)) name = "若潮〜中潮";
            
            if (lunarDate === 10 || lunarDate === 25) name = "長潮";
            else if (lunarDate === 11 || lunarDate === 26) name = "若潮";
            else if ([12, 13, 14, 27, 28, 29].includes(lunarDate)) name = "中潮";

            const baseOffset = 6.0; 
            const highTide1 = (moonAge * (24 / 29.53) + baseOffset) % 24;
            const highTide2 = (highTide1 + 12.42) % 24;
            
            const currentHour = targetDate.getHours() + targetDate.getMinutes()/60;
            let targetHT = highTide1;
            if (Math.abs(currentHour - highTide2) < Math.abs(currentHour - highTide1)) targetHT = highTide2;
            if (Math.abs(currentHour - (highTide1 + 24)) < Math.abs(currentHour - targetHT)) targetHT = highTide1 + 24;
            if (Math.abs(currentHour - (highTide2 - 24)) < Math.abs(currentHour - targetHT)) targetHT = highTide2 - 24;

            const diff = targetHT - currentHour;
            let trendText = "", trendClass = "";

            if (diff > 0) {
                if (diff < 1.5) { trendText = "満潮付近 (止まり)"; trendClass = "tide-trend"; }
                else { trendText = "上げ潮 ↗"; trendClass = "tide-trend"; }
            } else {
                if (Math.abs(diff) < 1.5) { trendText = "満潮付近 (止まり)"; trendClass = "tide-trend down"; }
                else { trendText = "下げ潮 ↘"; trendClass = "tide-trend down"; }
            }

            const amp = 1.0 + 0.3 * Math.cos((moonAge / 14.76) * Math.PI * 2);

            return { name, moonAge: moonAge.toFixed(1), trendText, trendClass, highTide1, amp, currentHour };
        }

        // --- Tide Graph (50px height) ---
        function drawTideGraph(tideInfo) {
            const canvas = document.getElementById('tideCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const gradient = ctx.createLinearGradient(0, 0, 0, h);
            gradient.addColorStop(0, "rgba(52, 152, 219, 0.6)");
            gradient.addColorStop(1, "rgba(52, 152, 219, 0.05)");

            const ht = tideInfo.highTide1;
            const amp = tideInfo.amp; 
            
            ctx.beginPath();
            ctx.moveTo(0, h);
            for (let x = 0; x <= w; x++) {
                const time = (x / w) * 24;
                const wave = Math.cos(2 * Math.PI * (time - ht) / 12.42);
                const y = (h / 2) + (wave * -1 * (h * 0.35 * amp));
                ctx.lineTo(x, y);
            }
            ctx.lineTo(w, h);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = "#3498db";
            ctx.lineWidth = 2;
            ctx.stroke();

            const currentH = tideInfo.currentHour;
            let displayH = currentH; 
            if(displayH < 0) displayH += 24;
            if(displayH > 24) displayH -= 24;

            const currentX = (displayH / 24) * w;

            ctx.beginPath();
            ctx.moveTo(currentX, 0);
            ctx.lineTo(currentX, h);
            ctx.strokeStyle = "rgba(231, 76, 60, 0.8)";
            ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 2]);
            ctx.stroke();
            ctx.setLineDash([]);

            const currentWave = Math.cos(2 * Math.PI * (displayH - ht) / 12.42);
            const currentY = (h / 2) + (currentWave * -1 * (h * 0.35 * amp));
            
            ctx.beginPath();
            ctx.arc(currentX, currentY, 4, 0, Math.PI * 2);
            ctx.fillStyle = "#e74c3c";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // --- Data Fetching ---
        async function fetchForecastData() {
            const lats = spots.map(s => s.lat).join(',');
            const lons = spots.map(s => s.lon).join(',');
            
            const mUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${lats}&longitude=${lons}&hourly=wave_height,swell_wave_direction&timezone=Asia%2FTokyo&forecast_days=2`;
            const wUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lats}&longitude=${lons}&hourly=wind_speed_10m,wind_direction_10m&wind_speed_unit=ms&timezone=Asia%2FTokyo&forecast_days=2`;

            try {
                const [mRes, wRes] = await Promise.all([
                    fetch(mUrl).then(r => r.json()),
                    fetch(wUrl).then(r => r.json())
                ]);

                const mDataList = Array.isArray(mRes) ? mRes : [mRes];
                const wDataList = Array.isArray(wRes) ? wRes : [wRes];

                globalData = [];

                const y = hourLabels[0].getFullYear();
                const m = String(hourLabels[0].getMonth() + 1).padStart(2, '0');
                const d = String(hourLabels[0].getDate()).padStart(2, '0');
                const h = String(hourLabels[0].getHours()).padStart(2, '0');
                const currentHourStr = `${y}-${m}-${d}T${h}`; 

                spots.forEach((spot, i) => {
                    const mHourly = mDataList[i].hourly;
                    const wHourly = wDataList[i].hourly;
                    
                    let startIndex = 0;
                    if(mHourly && mHourly.time) {
                        const idx = mHourly.time.findIndex(t => t.startsWith(currentHourStr));
                        if(idx !== -1) startIndex = idx;
                    }

                    const spotData = [];
                    for(let h=0; h<24; h++) {
                        const targetIdx = startIndex + h;
                        
                        if(!mHourly.wave_height[targetIdx] && mHourly.wave_height[targetIdx] !== 0) {
                             spotData.push({ hasData: false });
                             continue;
                        }

                        // ★補正計算
                        let rawWaveHeight = mHourly.wave_height[targetIdx];
                        if (spot.adjust) {
                            rawWaveHeight *= spot.adjust;
                        }

                        spotData.push({
                            hasData: true,
                            wave_height: rawWaveHeight, // 補正後の値
                            swell_dir: mHourly.swell_wave_direction[targetIdx],
                            wind_speed: wHourly.wind_speed_10m[targetIdx],
                            wind_dir: wHourly.wind_direction_10m[targetIdx]
                        });
                    }
                    globalData.push(spotData);
                });

                document.getElementById('loading-overlay').style.display = 'none';
                
                updateMapState(0);

            } catch(e) {
                console.error(e);
                document.getElementById('loading-overlay').innerText = "データ取得エラー";
            }
        }

        // --- Main Update ---
        function updateMapState(timeIndex) {
            const targetDate = hourLabels[timeIndex];
            const mm = targetDate.getMonth() + 1;
            const dd = targetDate.getDate();
            const hh = targetDate.getHours();
            const timeStr = `${mm}/${dd} ${String(hh).padStart(2,'0')}:00`;
            
            document.getElementById('current-time-display').innerText = timeIndex === 0 ? "現在" : timeStr;
            document.getElementById('p-data-time').innerText = timeStr;

            const tideInfo = getTideInfo(targetDate);

            // Markers
            spots.forEach((spot, i) => {
                const data = globalData[i][timeIndex];
                let iconHtml = '';
                
                if (data && data.hasData) {
                    const wh = data.wave_height;
                    const ws = data.wind_speed;
                    const wd = data.wind_dir;

                    let cClass = 'c-calm';
                    if(wh >= 0.5) cClass = 'c-mod';
                    if(wh >= 1.5) cClass = 'c-high';

                    let waveScale = 1.3;
                    let windRotate = wd + 180;
                    let windArrowColor = "#888";
                    if(ws < 4.0) windArrowColor = "#3498db"; 
                    else if(ws < 8.0) windArrowColor = "#f1c40f"; 
                    else windArrowColor = "#e74c3c"; 

                    iconHtml = `
                        <div class="surf-pin-container">
                            <div class="wind-ring" style="transform: rotate(${windRotate}deg)">
                                <div class="arrow-pointer" style="border-bottom-color: ${windArrowColor}"></div>
                            </div>
                            <div class="wave-core ${cClass}" style="transform: scale(${waveScale})"></div>
                        </div>
                    `;
                } else {
                    iconHtml = `
                        <div class="surf-pin-container">
                            <div class="wave-core c-none"></div>
                        </div>
                    `;
                }

                if(!spotMarkers[i]) {
                    const icon = L.divIcon({ className: 'custom-div', html: iconHtml, iconSize: [50, 50], iconAnchor: [25, 25] });
                    const m = L.marker([spot.lat, spot.lon], {icon: icon, zIndexOffset: 1000}).addTo(map);
                    
                    m.on('click', (e) => {
                        L.DomEvent.stopPropagation(e);
                        selectedSpotIndex = i;
                        renderInfoPanel(i);
                    });
                    spotMarkers.push(m);
                } else {
                    const icon = L.divIcon({ className: 'custom-div', html: iconHtml, iconSize: [50, 50], iconAnchor: [25, 25] });
                    spotMarkers[i].setIcon(icon);
                }
            });

            // Wind BG
            const vectors = [];
            spots.forEach((spot, i) => {
                const d = globalData[i][timeIndex];
                if(d && d.hasData && d.wind_speed > 0) {
                    const rad = d.wind_dir * (Math.PI / 180);
                    vectors.push({
                        lat: spot.lat, lon: spot.lon,
                        u: -d.wind_speed * Math.sin(rad),
                        v: -d.wind_speed * Math.cos(rad),
                        speed: d.wind_speed
                    });
                }
            });
            drawAnimatedWind(vectors);

            if(selectedSpotIndex !== null) {
                renderInfoPanel(selectedSpotIndex);
            }
        }

        function renderInfoPanel(index) {
            const data = globalData[index][currentHourIndex];
            const spot = spots[index];
            const panel = document.getElementById('info-panel');
            const targetDate = hourLabels[currentHourIndex];
            const tideInfo = getTideInfo(targetDate);

            document.getElementById('p-name').innerText = spot.name;

            if (data && data.hasData) {
                const wh = data.wave_height;
                const ws = data.wind_speed;
                const swellDir = data.swell_dir;
                const wd = data.wind_dir;

                document.getElementById('p-wave-cond').innerText = getSurfConditionText(wh);
                document.getElementById('p-wave').innerText = `${wh.toFixed(2)} m`;
                document.getElementById('p-swell').innerText = `${getDirText(swellDir)} (${Math.round(swellDir)}°)`;
                document.getElementById('p-wind').innerText = `${ws.toFixed(1)} m/s`;
                document.getElementById('p-wdir').innerText = `${getDirText(wd)} (${Math.round(wd)}°)`;
            } else {
                document.getElementById('p-wave-cond').innerText = "データなし";
                document.getElementById('p-wave').innerText = "-- m";
                document.getElementById('p-swell').innerText = "--";
                document.getElementById('p-wind').innerText = "--";
                document.getElementById('p-wdir').innerText = "--";
            }

            document.getElementById('p-tide-name').innerText = tideInfo.name;
            const trendEl = document.getElementById('p-tide-trend');
            trendEl.innerText = tideInfo.trendText;
            trendEl.className = `val ${tideInfo.trendClass}`;
            
            drawTideGraph(tideInfo);
            panel.style.display = 'block';
        }

        function drawAnimatedWind(vectors) {
            windLayerGroup.clearLayers();
            const gridStep = 0.7; 
            const latTop = 46.0, latBottom = 24.0;
            const lonLeft = 122.0, lonRight = 148.0;

            for(let lat = latTop; lat >= latBottom; lat -= gridStep) {
                for(let lon = lonLeft; lon <= lonRight; lon += gridStep) {
                    let sumU = 0, sumV = 0, sumW = 0;
                    let minDistance = 9999;
                    for(const vec of vectors) {
                        const d2 = Math.pow(lat - vec.lat, 2) + Math.pow(lon - vec.lon, 2);
                        const d = Math.sqrt(d2);
                        if(d < minDistance) minDistance = d;
                        const w = 1.0 / (d2 + 0.05); 
                        sumU += vec.u * w;
                        sumV += vec.v * w;
                        sumW += w;
                    }
                    if(minDistance > 4.5) continue;
                    if(sumW > 0) {
                        const u = sumU / sumW;
                        const v = sumV / sumW;
                        const speed = Math.sqrt(u*u + v*v);
                        let degree = (Math.atan2(-u, -v) * 180 / Math.PI) + 180; 
                        addAnimatedArrow(lat, lon, degree, speed);
                    }
                }
            }
        }

        function addAnimatedArrow(lat, lon, degree, speed) {
            let scale = 0.8; let opacity = 0.5;
            if(speed > 5) { scale = 1.0; opacity = 0.7; }
            if(speed > 10) { scale = 1.2; opacity = 0.9; }
            let animDuration = Math.max(0.5, 2.0 - (speed * 0.1));
            let animDelay = -Math.random() * 2;
            const svgArrow = `
                <svg width="30" height="30" viewBox="0 0 24 24" class="arrow-svg" style="transform: rotate(${degree}deg) scale(${scale}); opacity: ${opacity};">
                    <path d="M12 2 L6 18 L12 14 L18 18 Z" fill="#555" stroke="none" style="animation-duration: ${animDuration}s; animation-delay: ${animDelay}s;"/>
                </svg>
            `;
            const icon = L.divIcon({ className: 'wind-arrow-icon', html: svgArrow, iconSize: [30, 30], iconAnchor: [15, 15] });
            L.marker([lat, lon], { icon: icon, interactive: false, zIndexOffset: -100 }).addTo(windLayerGroup);
        }

        const slider = document.getElementById('time-slider');
        const playBtn = document.getElementById('play-btn');

        slider.addEventListener('input', (e) => {
            currentHourIndex = parseInt(e.target.value);
            updateMapState(currentHourIndex);
            if(isPlaying) stopPlay();
        });

        playBtn.addEventListener('click', () => {
            if(isPlaying) stopPlay();
            else startPlay();
        });

        function startPlay() {
            isPlaying = true;
            playBtn.innerText = "||";
            playInterval = setInterval(() => {
                currentHourIndex++;
                if(currentHourIndex > 23) currentHourIndex = 0;
                slider.value = currentHourIndex;
                updateMapState(currentHourIndex);
            }, 1000); 
        }

        function stopPlay() {
            isPlaying = false;
            playBtn.innerText = "▶";
            clearInterval(playInterval);
        }

        fetchForecastData();

    </script>
</body>
</html>