<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Japan Surf Condition Map</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        body, html { margin: 0; padding: 0; height: 100%; font-family: 'Helvetica Neue', Arial, sans-serif; overflow: hidden; }
        #map { height: 100%; width: 100%; background: #e5e5e5; }

        /* 情報パネル */
        #info-panel {
            position: absolute; top: 20px; right: 20px; width: 300px;
            background: rgba(255, 255, 255, 0.98); padding: 20px; border-radius: 12px;
            box-shadow: 0 4px 25px rgba(0,0,0,0.15); z-index: 1000; display: none;
            backdrop-filter: blur(5px);
            pointer-events: auto; 
        }
        
        /* 取得時間の表示スタイル */
        #p-update-time {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 0.7rem;
            color: #aaa;
            font-weight: normal;
        }

        .row { display: flex; justify-content: space-between; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px;}
        .label { color: #666; font-size: 0.85rem; }
        .val { font-weight: bold; color: #333; text-align: right; font-size: 0.95rem;}
        .sub-val { font-size: 0.8rem; color: #888; font-weight: normal; display: block; }
        
        .note-text { font-size: 0.7rem; color: #999; margin-top: 4px; line-height: 1.2; text-align: right; }

        /* 潮回りタグ */
        .tide-tag {
            display: inline-block; padding: 2px 8px; border-radius: 4px; 
            font-size: 0.8rem; color: white; background: #555; margin-right: 5px;
        }
        .tide-trend { font-weight: bold; color: #007bff; font-size: 0.9rem; }
        .tide-trend.down { color: #dc3545; }

        /* タイドグラフ */
        #tide-graph-container {
            margin-top: 5px;
            text-align: center;
            background: linear-gradient(to bottom, #fcfcfc, #f0f8ff);
            border-radius: 8px;
            padding: 10px 0;
            border: 1px solid #e0e0e0;
        }
        canvas { width: 100%; height: 80px; }

        /* ■■■ マーカーデザイン ■■■ */
        .surf-pin-container {
            position: relative;
            width: 50px; height: 50px; /* コンテナサイズ */
            display: flex; align-items: center; justify-content: center;
        }

        /* 中心の波サークル */
        .wave-core {
            width: 16px; height: 16px; 
            border-radius: 50%; 
            border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 2; /* 矢印より上に表示 */
            transition: transform 0.3s ease;
        }
        /* インタラクション */
        .surf-pin-container:hover .wave-core {
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            cursor: pointer;
        }

        /* 風の矢印リング */
        .wind-ring {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* クリックを透過して下のマーカーへ */
            z-index: 1;
        }
        
        /* 矢印の三角形 */
        .arrow-pointer {
            position: absolute;
            top: 2px; /* リングの上端に配置 */
            left: 50%;
            transform: translateX(-50%);
            width: 0; height: 0; 
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 14px solid #888; /* 色はJSで上書き */
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
        }

        /* 波の色定義 */
        .c-calm { background: #3498db; } /* 青 */
        .c-mod { background: #f1c40f; }  /* 黄 */
        .c-high { background: #e74c3c; } /* 赤 */
        .c-none { background: #b0b0b0; } /* グレー */

        /* 背景の風アニメーション用 */
        .wind-arrow-icon {
            display: flex; align-items: center; justify-content: center;
            pointer-events: none; 
        }
        .arrow-svg path {
            animation-name: flow;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }
        @keyframes flow {
            0% { opacity: 0; transform: translateY(8px); }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translateY(-8px); }
        }

        #status-bar {
            position: absolute; bottom: 10px; left: 10px; 
            background: rgba(255, 255, 255, 0.9); color: #333; 
            padding: 5px 15px; border-radius: 20px; font-size: 12px; font-weight: bold;
            z-index: 3000; pointer-events: none; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>

    <div id="status-bar">システム起動中...</div>
    <div id="map"></div>
    
    <div id="info-panel">
        <div id="p-update-time"></div>
        <h3 id="p-name" style="margin-top:0; margin-bottom:10px; font-size:1.2rem;">-</h3>
        
        <div class="row" style="border-bottom: none; margin-bottom: 0;">
            <span class="label">波高 (目安)</span>
            <div style="text-align:right;">
                <div id="p-wave-cond" class="val">-</div>
                <div id="p-wave" class="sub-val">- m</div>
            </div>
        </div>
        <div class="note-text" style="margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #eee;">
            ※地形や潮回りにより、実際に<br>ブレイクするサイズは前後します
        </div>

        <div class="row">
            <span class="label">うねり</span>
            <div style="text-align:right;">
                <span id="p-swell" class="val">-</span>
            </div>
        </div>

        <div class="row">
            <span class="label">風速</span>
            <div style="text-align:right;">
                <span id="p-wind" class="val">-</span>
                <div id="p-wdir" class="sub-val">-</div>
            </div>
        </div>

        <hr style="border:0; border-top:1px solid #eee; margin: 5px 0 10px 0;">

        <div class="row" style="background: #f9f9f9; padding: 8px; border-radius: 6px; border: none; margin-bottom: 5px;">
            <span class="label">潮回り</span>
            <div style="text-align:right;">
                <div style="margin-bottom:4px;">
                    <span id="p-tide-name" class="tide-tag">-</span>
                    <span id="p-moon-age" style="font-size:0.8rem; color:#999;">(月齢 -)</span>
                </div>
                <div id="p-tide-trend" class="val">-</div>
            </div>
        </div>

        <div id="tide-graph-container">
            <canvas id="tideCanvas" width="280" height="80"></canvas>
            <div style="font-size:0.7rem; color:#999; display:flex; justify-content:space-between; padding:0 10px;">
                <span>0</span><span>6</span><span>12</span><span>18</span><span>24</span>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        function setStatus(msg) {
            document.getElementById('status-bar').innerText = msg;
        }

        // 地図の表示範囲を日本に限定する設定
        const southWest = L.latLng(20.0, 122.0); // 沖縄の南西
        const northEast = L.latLng(46.0, 154.0); // 北海道の北東
        const bounds = L.latLngBounds(southWest, northEast);

        const map = L.map('map', { 
            zoomControl: false,
            maxBounds: bounds,      // 画面をこの範囲から出られないようにロック
            maxBoundsViscosity: 1.0, // 引っ張っても戻らず、完全に止める
            minZoom: 5              // これ以上ズームアウトさせない
        }).setView([37.5, 139.0], 5); 

        L.control.zoom({ position: 'topleft' }).addTo(map);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19, 
            attribution: '&copy; CARTO',
            bounds: bounds // タイル読み込みも制限
        }).addTo(map);

        map.on('click', () => {
            document.getElementById('info-panel').style.display = 'none';
        });
        const panel = document.getElementById('info-panel');
        L.DomEvent.disableClickPropagation(panel);

        // ■ ポイント定義
        const spots = [
            // 北海道・東北
            { name: "北海道 - 浜厚真", lat: 42.605, lon: 141.832 },
            { name: "北海道 - 室蘭イタンキ", lat: 42.327, lon: 141.037 },
            { name: "青森 - 三沢", lat: 40.702, lon: 141.428 },
            { name: "岩手 - 浪板", lat: 39.358, lon: 141.933 },
            { name: "秋田 - 男鹿", lat: 39.850, lon: 139.750 }, 
            { name: "宮城 - 仙台新港", lat: 38.276, lon: 141.026 }, 
            { name: "福島 - 北泉", lat: 37.647, lon: 141.028 }, 
            { name: "福島 - 岩沢", lat: 37.268, lon: 141.020 }, 
            { name: "日本海 - 新潟", lat: 37.880, lon: 138.940 }, // 五十嵐周辺
            { name: "石川 - 柴垣", lat: 36.908, lon: 136.762 },
            
            // 茨城
            { name: "茨城 - 大洗", lat: 36.307, lon: 140.575 },
            { name: "茨城 - トップサンテ", lat: 36.195, lon: 140.575 },

            // 千葉
            { name: "千葉 - 片貝", lat: 35.538, lon: 140.460 },
            { name: "千葉 - 一宮", lat: 35.365, lon: 140.395 },
            { name: "千葉 - 御宿", lat: 35.182, lon: 140.355 },
            { name: "千葉 - 和田", lat: 35.038, lon: 140.023 },
            { name: "千葉 - 鴨川", lat: 35.105, lon: 140.115 },
            
            // 神奈川
            { name: "湘南 - 由比ガ浜", lat: 35.3120, lon: 139.5415 }, 
            { name: "湘南 - 七里ヶ浜", lat: 35.3058, lon: 139.5105 }, 
            { name: "湘南 - 鵠沼", lat: 35.3165, lon: 139.4685 },     
            { name: "湘南 - 茅ヶ崎", lat: 35.3168, lon: 139.4045 },   
            { name: "湘南 - 平塚", lat: 35.3155, lon: 139.3615 },     
            { name: "西湘 - 吉浜", lat: 35.1505, lon: 139.1125 },     
            
            // 静岡・愛知
            { name: "静岡 - 白浜", lat: 34.688, lon: 138.975 },
            { name: "静岡 - 静波", lat: 34.752, lon: 138.275 },
            { name: "静岡 - 御前崎", lat: 34.595, lon: 138.225 },
            { name: "愛知 - 伊良湖", lat: 34.598, lon: 137.150 }, 
            
            // 西日本
            { name: "京都 - 八丁浜", lat: 35.688, lon: 135.062 },
            { name: "和歌山 - 磯の浦", lat: 34.257, lon: 135.075 }, 
            { name: "高知 - 生見", lat: 33.542, lon: 134.305 },
            { name: "高知 - 入野", lat: 33.020, lon: 133.005 },

            // 九州・沖縄
            { name: "福岡 - 釣川", lat: 33.875, lon: 130.535 },
            { name: "福岡 - 三苫", lat: 33.705, lon: 130.422 }, 
            { name: "福岡 - 芥屋", lat: 33.615, lon: 130.130 },
            { name: "宮崎 - お倉ヶ浜", lat: 32.410, lon: 131.670 },
            { name: "宮崎 - 木崎浜", lat: 31.825, lon: 131.445 },
            { name: "沖縄 - 砂辺", lat: 26.328, lon: 127.745 }
        ];

        const windLayerGroup = L.layerGroup().addTo(map);
        
        let dataFetchTimeStr = "--/-- --:--"; 

        function getDirText(deg) {
            const dirs = ['北', '北東', '東', '南東', '南', '南西', '西', '北西'];
            return dirs[Math.round(deg / 45) % 8];
        }

        // ▼▼▼ 修正箇所: 波のサイズ定義を更新しました ▼▼▼
        function getSurfConditionText(height) {
            if (height === null || height === undefined) return "データなし";
            if (height < 0.30) return "ひざ";
            if (height < 0.40) return "ひざ前後";
            if (height < 0.50) return "もも前後";
            if (height < 0.60) return "もも腰";
            if (height < 0.70) return "腰前後";
            if (height < 0.80) return "腰腹";
            if (height < 0.90) return "腹前後";
            if (height < 1.00) return "腹胸前後";
            if (height < 1.10) return "胸前後";
            if (height < 1.20) return "胸前後";
            if (height < 1.30) return "胸肩前後";
            if (height < 1.40) return "胸肩前後";
            if (height < 1.50) return "肩前後";
            if (height < 1.60) return "肩前後";
            if (height < 1.70) return "頭前後";
            if (height < 1.80) return "頭オーバー";
            return "クローズ"; 
        }
        // ▲▲▲ 修正完了 ▲▲▲

        // 潮汐ロジック
        function getTideInfo() {
            const now = new Date();
            const knownNewMoon = new Date(2024, 0, 11, 20, 57); 
            const cycle = 29.53059;
            const diffTime = now.getTime() - knownNewMoon.getTime();
            const diffDays = diffTime / (1000 * 60 * 60 * 24);
            let moonAge = diffDays % cycle;
            if (moonAge < 0) moonAge += cycle;

            const lunarDate = Math.floor(moonAge) + 1;
            let name = "中潮";
            
            if ([1, 2, 15, 16, 17, 30].includes(lunarDate)) name = "大潮";
            else if ([3, 4, 5, 18, 19, 20, 21].includes(lunarDate)) name = "中潮";
            else if ([6, 7, 8, 22, 23, 24].includes(lunarDate)) name = "小潮";
            else if ([9, 25].includes(lunarDate)) name = "長潮";
            else if ([10, 11, 12, 13, 14, 26, 27, 28, 29].includes(lunarDate)) name = "若潮〜中潮";
            
            if (lunarDate === 10 || lunarDate === 25) name = "長潮";
            else if (lunarDate === 11 || lunarDate === 26) name = "若潮";
            else if ([12, 13, 14, 27, 28, 29].includes(lunarDate)) name = "中潮";

            const baseOffset = 6.0; 
            const highTide1 = (moonAge * (24 / 29.53) + baseOffset) % 24;
            const highTide2 = (highTide1 + 12.42) % 24;
            
            const currentHour = now.getHours() + now.getMinutes()/60;
            let targetHT = highTide1;
            if (Math.abs(currentHour - highTide2) < Math.abs(currentHour - highTide1)) targetHT = highTide2;
            if (Math.abs(currentHour - (highTide1 + 24)) < Math.abs(currentHour - targetHT)) targetHT = highTide1 + 24;
            if (Math.abs(currentHour - (highTide2 - 24)) < Math.abs(currentHour - targetHT)) targetHT = highTide2 - 24;

            const diff = targetHT - currentHour;
            let trendText = "", trendClass = "";

            if (diff > 0) {
                if (diff < 1.5) { trendText = "満潮付近 (止まり)"; trendClass = "tide-trend"; }
                else { trendText = "上げ潮 ↗"; trendClass = "tide-trend"; }
            } else {
                if (Math.abs(diff) < 1.5) { trendText = "満潮付近 (止まり)"; trendClass = "tide-trend down"; }
                else { trendText = "下げ潮 ↘"; trendClass = "tide-trend down"; }
            }

            const amp = 1.0 + 0.3 * Math.cos((moonAge / 14.76) * Math.PI * 2);

            return { name, moonAge: moonAge.toFixed(1), trendText, trendClass, highTide1, amp };
        }

        function drawTideGraph(tideInfo) {
            const canvas = document.getElementById('tideCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);

            const gradient = ctx.createLinearGradient(0, 0, 0, h);
            gradient.addColorStop(0, "rgba(52, 152, 219, 0.6)");
            gradient.addColorStop(1, "rgba(52, 152, 219, 0.05)");

            const ht = tideInfo.highTide1;
            const amp = tideInfo.amp; 
            
            ctx.beginPath();
            ctx.moveTo(0, h);

            for (let x = 0; x <= w; x++) {
                const time = (x / w) * 24;
                const wave = Math.cos(2 * Math.PI * (time - ht) / 12.42);
                const y = (h / 2) + (wave * -1 * (h * 0.30 * amp));
                ctx.lineTo(x, y);
            }

            ctx.lineTo(w, h);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = "#3498db";
            ctx.lineWidth = 2;
            ctx.stroke();

            const now = new Date();
            const currentH = now.getHours() + now.getMinutes() / 60;
            const currentX = (currentH / 24) * w;

            ctx.beginPath();
            ctx.moveTo(currentX, 0);
            ctx.lineTo(currentX, h);
            ctx.strokeStyle = "rgba(231, 76, 60, 0.8)";
            ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 2]);
            ctx.stroke();
            ctx.setLineDash([]);

            const currentWave = Math.cos(2 * Math.PI * (currentH - ht) / 12.42);
            const currentY = (h / 2) + (currentWave * -1 * (h * 0.30 * amp));
            
            ctx.beginPath();
            ctx.arc(currentX, currentY, 5, 0, Math.PI * 2);
            ctx.fillStyle = "#e74c3c";
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        async function init() {
            setStatus("気象データ取得中...");
            
            try {
                const lats = spots.map(s => s.lat).join(',');
                const lons = spots.map(s => s.lon).join(',');
                
                const mUrl = `https://marine-api.open-meteo.com/v1/marine?latitude=${lats}&longitude=${lons}&current=wave_height,swell_wave_direction&timezone=Asia%2FTokyo`;
                const wUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lats}&longitude=${lons}&current=wind_speed_10m,wind_direction_10m&wind_speed_unit=ms`;

                const [mRes, wRes] = await Promise.all([
                    fetch(mUrl).then(r => r.json()),
                    fetch(wUrl).then(r => r.json())
                ]);

                // 取得時間の保存処理
                const now = new Date();
                const mm = now.getMonth() + 1;
                const dd = now.getDate();
                const hh = now.getHours();
                const min = String(now.getMinutes()).padStart(2, '0');
                dataFetchTimeStr = `${mm}/${dd} ${hh}:${min}時点`;

                setStatus("マップ描画中...");

                const mData = Array.isArray(mRes) ? mRes : [mRes];
                const wData = Array.isArray(wRes) ? wRes : [wRes];
                const windVectors = [];
                const tideInfo = getTideInfo();

                spots.forEach((spot, i) => {
                    let wh = null, swellDir = 0, ws = 0, wd = 0;
                    let hasData = false;

                    if(mData[i] && mData[i].current && wData[i] && wData[i].current) {
                        wh = mData[i].current.wave_height;
                        swellDir = mData[i].current.swell_wave_direction;
                        ws = wData[i].current.wind_speed_10m;
                        wd = wData[i].current.wind_direction_10m;
                        if (wh !== null && wh !== undefined) {
                            hasData = true;
                        }
                    }

                    // --- 波の色判定 ---
                    let cClass = 'c-none'; 
                    if (hasData) {
                        if(wh < 0.5) cClass = 'c-calm';
                        else if(wh < 1.5) cClass = 'c-mod';
                        else cClass = 'c-high';
                    }

                    let waveScale = 1.3; // 一定の大きさに固定

                    let windRotate = hasData ? (wd + 180) : 0;
                    
                    let windArrowColor = "#888"; 
                    if (hasData) {
                        if(ws < 4.0) windArrowColor = "#3498db"; 
                        else if(ws < 8.0) windArrowColor = "#f1c40f"; 
                        else windArrowColor = "#e74c3c"; 
                    }

                    // HTML生成
                    const iconHtml = `
                        <div class="surf-pin-container">
                            <div class="wind-ring" style="transform: rotate(${windRotate}deg)">
                                <div class="arrow-pointer" style="border-bottom-color: ${windArrowColor}"></div>
                            </div>
                            <div class="wave-core ${cClass}" style="transform: scale(${waveScale})"></div>
                        </div>
                    `;

                    const icon = L.divIcon({
                        className: 'custom-div', 
                        html: iconHtml,
                        iconSize: [50, 50], 
                        iconAnchor: [25, 25] 
                    });

                    const marker = L.marker([spot.lat, spot.lon], {icon: icon, zIndexOffset: 1000}).addTo(map);
                    
                    marker.on('click', (e) => {
                        L.DomEvent.stopPropagation(e);
                        const panel = document.getElementById('info-panel');
                        document.getElementById('p-name').innerText = spot.name;
                        
                        document.getElementById('p-update-time').innerText = "データ取得: " + dataFetchTimeStr;

                        if (hasData) {
                            document.getElementById('p-wave-cond').innerText = getSurfConditionText(wh);
                            document.getElementById('p-wave').innerText = `${wh.toFixed(2)} m`;
                            document.getElementById('p-swell').innerText = `${getDirText(swellDir)} (${Math.round(swellDir)}°)`;
                            document.getElementById('p-wind').innerText = `${ws.toFixed(1)} m/s`;
                            document.getElementById('p-wdir').innerText = `${getDirText(wd)} (${Math.round(wd)}°)`;
                        } else {
                            document.getElementById('p-wave-cond').innerText = "データなし";
                            document.getElementById('p-wave').innerText = "-- m";
                            document.getElementById('p-swell').innerText = "--";
                            document.getElementById('p-wind').innerText = "--";
                            document.getElementById('p-wdir').innerText = "--";
                        }

                        document.getElementById('p-tide-name').innerText = tideInfo.name;
                        const trendEl = document.getElementById('p-tide-trend');
                        trendEl.innerText = tideInfo.trendText;
                        trendEl.className = `val ${tideInfo.trendClass}`;
                        
                        drawTideGraph(tideInfo);
                        
                        panel.style.display = 'block';
                    });

                    if (hasData && ws > 0) {
                        const rad = wd * (Math.PI / 180);
                        windVectors.push({
                            lat: spot.lat, lon: spot.lon,
                            u: -ws * Math.sin(rad),
                            v: -ws * Math.cos(rad),
                            speed: ws
                        });
                    }
                });

                drawAnimatedWind(windVectors);
                setStatus("表示完了");

            } catch(e) {
                console.error(e);
                setStatus("データ取得エラー");
            }
        }

        function drawAnimatedWind(vectors) {
            windLayerGroup.clearLayers();
            const gridStep = 0.7; 
            const latTop = 46.0, latBottom = 24.0;
            const lonLeft = 122.0, lonRight = 148.0;

            for(let lat = latTop; lat >= latBottom; lat -= gridStep) {
                for(let lon = lonLeft; lon <= lonRight; lon += gridStep) {
                    let sumU = 0, sumV = 0, sumW = 0;
                    let minDistance = 9999;
                    for(const vec of vectors) {
                        const d2 = Math.pow(lat - vec.lat, 2) + Math.pow(lon - vec.lon, 2);
                        const d = Math.sqrt(d2);
                        if(d < minDistance) minDistance = d;
                        const w = 1.0 / (d2 + 0.05); 
                        sumU += vec.u * w;
                        sumV += vec.v * w;
                        sumW += w;
                    }
                    if(minDistance > 4.5) continue;
                    if(sumW > 0) {
                        const u = sumU / sumW;
                        const v = sumV / sumW;
                        const speed = Math.sqrt(u*u + v*v);
                        let degree = (Math.atan2(-u, -v) * 180 / Math.PI) + 180; 
                        addAnimatedArrow(lat, lon, degree, speed);
                    }
                }
            }
        }

        function addAnimatedArrow(lat, lon, degree, speed) {
            let scale = 0.8;
            let opacity = 0.5;
            if(speed > 5) { scale = 1.0; opacity = 0.7; }
            if(speed > 10) { scale = 1.2; opacity = 0.9; }
            let animDuration = Math.max(0.5, 2.0 - (speed * 0.1));
            let animDelay = -Math.random() * 2;
            const svgArrow = `
                <svg width="30" height="30" viewBox="0 0 24 24" class="arrow-svg" style="transform: rotate(${degree}deg) scale(${scale}); opacity: ${opacity};">
                    <path d="M12 2 L6 18 L12 14 L18 18 Z" fill="#555" stroke="none" style="animation-duration: ${animDuration}s; animation-delay: ${animDelay}s;"/>
                </svg>
            `;
            const icon = L.divIcon({
                className: 'wind-arrow-icon',
                html: svgArrow,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
            L.marker([lat, lon], { icon: icon, interactive: false, zIndexOffset: -100 }).addTo(windLayerGroup);
        }

        init();
    </script>
</body>
</html>